# 相关性计算和搜索逻辑说明

## 修复的问题

### 1. 搜索结果数量不足问题
**原问题：**
- 用户要求20篇文献
- 本地缓存6篇 → 外部搜索14篇 (20-6=14)
- 外部14篇与本地6篇去重后 → 最终可能只有15篇

**修复方案：**
- 添加 `external_search_count` 参数
- 外部始终搜索用户要求的完整数量 (如20篇)
- 与本地缓存去重后，从所有结果中选择前N篇

### 2. 相关性计算逻辑优化
**原问题：**
- 外部搜索结果相关性固定为0.9
- 缺乏基于搜索位置的相关性区分

**修复方案：**
- 基于搜索结果位置动态计算相关性
- 第1篇=0.95，第2篇=0.93，依此递减
- 最低相关性不低于0.7

## 相关性计算详解

### 本地缓存相关性计算
使用多层次搜索策略，每种策略有不同的相关性基准：

#### 策略1：MySQL全文搜索（最精确）
```sql
MATCH(title, abstract) AGAINST(? IN NATURAL LANGUAGE MODE) as relevance_score
```
- **计算方式**：MySQL内置全文搜索算法
- **基准分数**：≥0.95
- **实际分数**：`Math.max(0.95, MySQL计算分数)`

#### 策略2：扩展关键词语义匹配
```sql
WHERE (title LIKE ? OR abstract LIKE ?) 
```
- **计算方式**：关键词模糊匹配
- **基准分数**：0.9
- **适用场景**：全文搜索无结果时的补充

#### 策略3：基础关键词匹配（回退策略）
```sql
WHERE (title LIKE ? OR abstract LIKE ?)
```
- **计算方式**：原始关键词匹配
- **基准分数**：0.85
- **适用场景**：前两种策略都无结果时使用

#### 备用搜索策略
- **基准分数**：0.8
- **适用场景**：增强搜索失败时使用

#### 最新论文策略
- **基准分数**：0.7
- **适用场景**：所有搜索策略都失败时使用

### 外部搜索相关性计算
使用Semantic Scholar API的搜索结果，基于位置计算相关性：

```javascript
// 基于搜索结果位置计算相关性分数
const baseScore = 0.95 - (index * 0.02);
const relevanceScore = Math.max(0.7, baseScore);
```

**外部搜索分数分布：**
- 第1篇：0.95 (高相关性)
- 第2篇：0.93 (高相关性)
- 第3篇：0.91 (高相关性)
- 第4篇：0.89 (高相关性)
- 第5篇：0.87 (高相关性)
- ...
- 第13篇：0.71 (中等相关性)
- 第14篇及以后：0.7 (中等相关性)

**本地缓存分数分布：**
- MySQL全文搜索：≥0.95 (高相关性)
- 语义匹配：0.9 (高相关性)
- 基础匹配：0.85 (高相关性)
- 备用搜索：0.8 (高相关性)
- 最新论文：0.7 (中等相关性)

## 相关性等级映射

前端根据相关性分数显示不同颜色：

| 分数范围 | 等级 | 颜色 | 描述 |
|---------|------|------|------|
| ≥0.8 | high | 绿色 🟢 | 高相关性 |
| 0.6-0.79 | medium | 黄色 🟡 | 中等相关性 |
| 0.4-0.59 | low | 橙色 🟠 | 低相关性 |
| <0.4 | very-low | 红色 🔴 | 极低相关性 |

## 搜索流程优化

### 修复前的流程
1. 本地搜索N篇
2. 外部搜索 (目标数量-N) 篇
3. 去重合并
4. 结果可能不足目标数量

### 修复后的流程
1. 本地搜索N篇
2. 外部搜索完整目标数量篇
3. 去重合并 (总数可能超过目标)
4. 排序并取前目标数量篇
5. 确保结果数量满足用户需求

## 排序逻辑

最终结果按以下优先级排序：
1. **缓存优先**：本地缓存结果优先显示
2. **相关性排序**：按相关性分数降序
3. **引用次数**：相关性相同时按引用次数降序

```javascript
.sort((a, b) => {
  if (a.from_cache && !b.from_cache) return -1;
  if (!a.from_cache && b.from_cache) return 1;
  if (a.relevance_score !== b.relevance_score) return b.relevance_score - a.relevance_score;
  return b.citations - a.citations;
})
```

## 技术实现要点

### 后端API修改
- 添加 `external_search_count` 参数支持
- 动态相关性计算算法
- 改进的排序和去重逻辑

### 前端配合
- 传递 `external_search_count` 参数
- 相关性等级映射函数
- 颜色化显示组件

这些修改确保了搜索结果的数量充足性和相关性的准确性，提升了用户的搜索体验。 